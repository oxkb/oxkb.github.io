<!DOCTYPE html>
<html lang="am">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Online Amharic Keyboard (የአማርኛ ኪቦርድ) - Type Amharic Easily</title>

    <meta name="description" content="A free and easy-to-use online Amharic keyboard (Fidel keyboard) to type Amharic letters and characters directly in your browser. Supports physical keyboard input.">
    <meta name="keywords" content="Amharic keyboard, online Amharic keyboard, Fidel keyboard, type Amharic, አማርኛ ኪቦርድ, Ethiopian keyboard, Geez keyboard, free Amharic typing">
    <meta name="author" content="Ahmedhaji Sadik Umer">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://amkb.vercel.app/">
    <meta property="og:title" content="Online Amharic Keyboard (የአማርኛ ኪቦርድ) - Type Amharic Easily">
    <meta property="og:description" content="Free online Amharic Fidel keyboard for easy typing in your browser.">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://amkb.vercel.app/">
    <meta property="twitter:title" content="Online Amharic Keyboard (የአማርኛ ኪቦርድ) - Type Amharic Easily">
    <meta property="twitter:description" content="Free online Amharic Fidel keyboard for easy typing in your browser.">

    <meta name="google-site-verification" content="YOykyV7jEUg5Nj2GeyhHUcewf9WW-Ruyke1v23KePrY" />

    <link rel="stylesheet" href="style.css">

</head>
<body>

    <h1>Online Amharic Keyboard (የአማርኛ ኪቦርድ)</h1>

    <div class="main-layout">
        <div id="keyboard-container">
            <div id="variation-keys" class="keyboard-row"></div>
            </div>
        <textarea id="output" rows="8" placeholder="Type Amharic here..."></textarea>
    </div>

    <div class="keyboard-info">
        <strong>How to use your physical keyboard:</strong><br>
        Type a consonant (like <code>b</code>) followed by a vowel (<code>e, u, i, a, y, o</code>) to get different forms: <code>be</code> &rarr; በ, <code>bu</code> &rarr; ቡ, <code>bi</code> &rarr; ቢ, <code>ba</code> &rarr; ባ, <code>by</code> &rarr; ቤ, <code>bo</code> &rarr; ቦ.<br>
        Press a consonant key once to get the 6th form (e.g., <code>b</code> &rarr; ብ). For labialized forms, type 'wa' after the consonant (e.g., <code>bwa</code> &rarr; ቧ).<br>
        <strong>Special Characters:</strong> <code>h</code> &rarr; ሀ, <code>H</code> (Shift+h) &rarr; ሐ | <code>s</code> &rarr; ሰ, <code>S</code> (Shift+s) &rarr; ሠ | <code>t</code> &rarr; ተ, <code>T</code> (Shift+t) &rarr; ጠ | <code>c</code> &rarr; ቸ, <code>C</code> (Shift+c) &rarr; ጨ | <code>n</code> &rarr; ነ, <code>N</code> (Shift+n) &rarr; ኘ | <code>z</code> &rarr; ዘ, <code>Z</code> (Shift+z) &rarr; ዠ | <code>`</code> &rarr; ሸ | <code>.</code> &rarr; ። | <code>,</code> &rarr; ፣ | Shift+. &rarr; ፀ | Shift+, &rarr; ጸ
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const outputTextarea = document.getElementById('output');
        const keyboardContainer = document.getElementById('keyboard-container');
        const variationKeysContainer = document.getElementById('variation-keys');

        const fidelGroups = {
            'ሀ': ['ሀ', 'ሁ', 'ሂ', 'ሃ', 'ሄ', 'ህ', 'ሆ'], 'ለ': ['ለ', 'ሉ', 'ሊ', 'ላ', 'ሌ', 'ል', 'ሎ', 'ሏ'],
            'ሐ': ['ሐ', 'ሑ', 'ሒ', 'ሓ', 'ሔ', 'ሕ', 'ሖ', 'ሗ'], 'መ': ['መ', 'ሙ', 'ሚ', 'ማ', 'ሜ', 'ም', 'ሞ', 'ሟ'],
            'ሠ': ['ሠ', 'ሡ', 'ሢ', 'ሣ', 'ሤ', 'ሥ', 'ሦ', 'ሧ'], 'ረ': ['ረ', 'ሩ', 'ሪ', 'ራ', 'ሬ', 'ር', 'ሮ', 'ሯ'],
            'ሰ': ['ሰ', 'ሱ', 'ሲ', 'ሳ', 'ሴ', 'ስ', 'ሶ', 'ሷ'], 'ሸ': ['ሸ', 'ሹ', 'ሺ', 'ሻ', 'ሼ', 'ሽ', 'ሾ', 'ሿ'],
            'ቀ': ['ቀ', 'ቁ', 'ቂ', 'ቃ', 'ቄ', 'ቅ', 'ቆ', 'ቋ'], 'በ': ['በ', 'ቡ', 'ቢ', 'ባ', 'ቤ', 'ብ', 'ቦ', 'ቧ'],
            'ቨ': ['ቨ', 'ቩ', 'ቪ', 'ቫ', 'ቬ', 'ቭ', 'ቮ', 'ቯ'], 'ተ': ['ተ', 'ቱ', 'ቲ', 'ታ', 'ቴ', 'ት', 'ቶ', 'ቷ'],
            'ቸ': ['ቸ', 'ቹ', 'ቺ', 'ቻ', 'ቼ', 'ች', 'ቾ', 'ቿ'], 'ኀ': ['ኀ', 'ኁ', 'ኂ', 'ኃ', 'ኄ', 'ኅ', 'ኆ', 'ኋ'],
            'ነ': ['ነ', 'ኑ', 'ኒ', 'ና', 'ኔ', 'ን', 'ኖ', 'ኗ'], 'ኘ': ['ኘ', 'ኙ', 'ኚ', 'ኛ', 'ኜ', 'ኝ', 'ኞ', 'ኟ'],
            'አ': ['አ', 'ኡ', 'ኢ', 'ኣ', 'ኤ', 'እ', 'ኦ'], 'ከ': ['ከ', 'ኩ', 'ኪ', 'ካ', 'ኬ', 'ክ', 'ኮ', 'ኳ'],
            'ኸ': ['ኸ', 'ኹ', 'ኺ', 'ኻ', 'ኼ', 'ኽ', 'ኾ', 'ዃ'], 'ወ': ['ወ', 'ዉ', 'ዊ', 'ዋ', 'ዌ', 'ው', 'ዎ'],
            'ዐ': ['ዐ', 'ዑ', 'ዒ', 'ዓ', 'ዔ', 'ዕ', 'ዖ'], 'ዘ': ['ዘ', 'ዙ', 'ዚ', 'ዛ', 'ዜ', 'ዝ', 'ዞ', 'ዟ'],
            'ዠ': ['ዠ', 'ዡ', 'ዢ', 'ዣ', 'ዤ', 'ዥ', 'ዦ', 'ዧ'], 'የ': ['የ', 'ዩ', 'ዪ', 'ያ', 'ዬ', 'ይ', 'ዮ'],
            'ደ': ['ደ', 'ዱ', 'ዲ', 'ዳ', 'ዴ', 'ድ', 'ዶ', 'ዷ'], 'ጀ': ['ጀ', 'ጁ', 'ጂ', 'ጃ', 'ጄ', 'ጅ', 'ጆ', 'ጇ'],
            'ገ': ['ገ', 'ጉ', 'ጊ', 'ጋ', 'ጌ', 'ግ', 'ጎ', 'ጓ'], 'ጠ': ['ጠ', 'ጡ', 'ጢ', 'ጣ', 'ጤ', 'ጥ', 'ጦ', 'ጧ'],
            'ጨ': ['ጨ', 'ጩ', 'ጪ', 'ጫ', 'ጬ', 'ጭ', 'ጮ', 'ጯ'], 'ጰ': ['ጰ', 'ጱ', 'ጲ', 'ጳ', 'ጴ', 'ጵ', 'ጶ', 'ጷ'],
            'ጸ': ['ጸ', 'ጹ', 'ጺ', 'ጻ', 'ጼ', 'ጽ', 'ጾ', 'ጿ'], 'ፀ': ['ፀ', 'ፁ', 'ፂ', 'ፃ', 'ፄ', 'ፅ', 'ፆ'],
            'ፈ': ['ፈ', 'ፉ', 'ፊ', 'ፋ', 'ፌ', 'ፍ', 'ፎ', 'ፏ'], 'ፐ': ['ፐ', 'ፑ', 'ፒ', 'ፓ', 'ፔ', 'ፕ', 'ፖ']
        };

        const physicalKeyMapping = {
            'h': 'ሀ', 'l': 'ለ', 'm': 'መ', 'r': 'ረ', 's': 'ሰ', 'q': 'ቀ', 'b': 'በ',
            't': 'ተ', 'c': 'ቸ', 'n': 'ነ', 'x': 'አ', 'k': 'ከ', 'w': 'ወ', 'z': 'ዘ',
            'y': 'የ', 'd': 'ደ', 'j': 'ጀ', 'g': 'ገ', 'f': 'ፈ', 'p': 'ፐ', 'v': 'ቨ',
            // Shift variants
            'H': 'ሐ', 'S': 'ሠ', 'T': 'ጠ', 'C': 'ጨ', 'N': 'ኘ', 'K': 'ኸ', 'Z': 'ዠ',
            'V': 'ኀ', 'P': 'ጰ', 'X': 'ዐ',
            // Punctuation and others
            '`': 'ሸ', ',': '፣', '.': '።', ';': '፤', ':': '፡', '?': '?',
            // Shifted punctuation
            '<': 'ጸ', '>': 'ፀ'
        };

        const vowelMapping = { 'e': 0, 'u': 1, 'i': 2, 'a': 3, 'y': 4, 'o': 6 };

        let keySequence = '';
        let sequenceTimer = null;
        const SEQUENCE_TIMEOUT = 1200; // ms

        // --- Keyboard Layout Definition ---
        const keyboardLayout = [
            Object.keys(fidelGroups).slice(0, 10),
            Object.keys(fidelGroups).slice(10, 20),
            Object.keys(fidelGroups).slice(20, 30),
            Object.keys(fidelGroups).slice(30),
            ['ጸ', 'ፀ', '፡', '።', '፣', '፤', '?', '!', '(', ')'],
            ['Backspace', 'Space', 'Enter']
        ];

        // --- Core Functions ---
        function insertAtCursor(textToInsert) {
            const startPos = outputTextarea.selectionStart;
            const endPos = outputTextarea.selectionEnd;
            const currentVal = outputTextarea.value;
            outputTextarea.value = currentVal.substring(0, startPos) + textToInsert + currentVal.substring(endPos);
            const newCursorPos = startPos + textToInsert.length;
            outputTextarea.selectionStart = outputTextarea.selectionEnd = newCursorPos;
            outputTextarea.focus();
        }

        function processSpecialKey(keyType) {
            const selectionStart = outputTextarea.selectionStart;
            const selectionEnd = outputTextarea.selectionEnd;

            switch (keyType) {
                case 'Backspace':
                    if (selectionStart === selectionEnd && selectionStart > 0) {
                        outputTextarea.value = outputTextarea.value.slice(0, selectionStart - 1) + outputTextarea.value.slice(selectionEnd);
                        outputTextarea.selectionStart = outputTextarea.selectionEnd = selectionStart - 1;
                    } else if (selectionStart !== selectionEnd) {
                        outputTextarea.value = outputTextarea.value.slice(0, selectionStart) + outputTextarea.value.slice(selectionEnd);
                        outputTextarea.selectionStart = outputTextarea.selectionEnd = selectionStart;
                    }
                    break;
                case 'Space': insertAtCursor(' '); break;
                case 'Enter': insertAtCursor('\n'); break;
            }
        }

        function clearSequence(resolve = false) {
            if (sequenceTimer) clearTimeout(sequenceTimer);
            sequenceTimer = null;
            if (resolve && keySequence) {
                const baseChar = physicalKeyMapping[keySequence];
                if (baseChar && fidelGroups[baseChar] && fidelGroups[baseChar][5]) {
                    insertAtCursor(fidelGroups[baseChar][5]);
                }
            }
            keySequence = '';
        }

        function displayVariations(baseFidel) {
            const variations = fidelGroups[baseFidel];
            variationKeysContainer.innerHTML = '';
            if (!variations) return;

            // Use a DocumentFragment for performance
            const fragment = document.createDocumentFragment();
            variations.forEach(variation => {
                const keyElement = document.createElement('button');
                keyElement.textContent = variation;
                keyElement.classList.add('key');
                keyElement.dataset.key = variation;
                fragment.appendChild(keyElement);
            });
            variationKeysContainer.appendChild(fragment);
        }

        // --- Event Handlers ---
        function handleVirtualKeyboardClick(event) {
            const keyElement = event.target.closest('.key');
            if (!keyElement) return;

            clearSequence();
            const key = keyElement.dataset.key;

            if (key === 'Backspace' || key === 'Space' || key === 'Enter') {
                processSpecialKey(key);
            } else if (fidelGroups[key]) {
                displayVariations(key);
            } else {
                insertAtCursor(key);
                variationKeysContainer.innerHTML = '';
            }
        }

        function handlePhysicalKeyboardDown(event) {
            // Ignore if modifier keys (except Shift) are pressed for combos
            if (event.ctrlKey || event.altKey || event.metaKey) {
                clearSequence();
                return;
            }

            const key = event.key;

            // Handle special keys directly
            if (key === 'Backspace' || key === 'Enter' || key === ' ') {
                event.preventDefault();
                clearSequence(true); // Resolve any pending sequence first
                processSpecialKey(key === ' ' ? 'Space' : key);
                return;
            }

            // Ignore navigation/function keys
            if (key.length > 1 && key !== 'Shift') {
                clearSequence(true);
                return;
            }

            // Shift is a modifier, not a character to type
            if (key === 'Shift') return;

            event.preventDefault();
            if (sequenceTimer) clearTimeout(sequenceTimer);

            const newSequence = keySequence + key;

            // Case 1: Sequence is a vowel following a consonant
            if (keySequence && physicalKeyMapping[keySequence] && vowelMapping.hasOwnProperty(key)) {
                const baseFidel = physicalKeyMapping[keySequence];
                const variations = fidelGroups[baseFidel];
                const vowelIndex = vowelMapping[key];
                if (variations && variations[vowelIndex]) {
                    insertAtCursor(variations[vowelIndex]);
                }
                keySequence = '';
                return;
            }

            // Case 2: Labialized form (e.g., gwa -> ጓ)
            if (keySequence && newSequence.endsWith('wa')) {
                 const consonant = newSequence.slice(0, -2);
                 const baseFidel = physicalKeyMapping[consonant];
                 const variations = fidelGroups[baseFidel];
                 if(variations && variations.length > 7) {
                       insertAtCursor(variations[7]);
                       keySequence = '';
                       return;
                 }
            }

            // Case 3: The key itself is a direct mapping (e.g., '.', ',')
            if (physicalKeyMapping[key] && !physicalKeyMapping[newSequence]) {
                clearSequence(true); // Resolve previous sequence
                if(physicalKeyMapping[key]) {
                    const baseFidel = physicalKeyMapping[key];
                    if(fidelGroups[baseFidel]) { // It's a consonant
                        keySequence = key;
                        displayVariations(baseFidel);
                        sequenceTimer = setTimeout(() => clearSequence(true), SEQUENCE_TIMEOUT);
                    } else { // It's a direct punctuation
                        insertAtCursor(baseFidel);
                        keySequence = '';
                    }
                }
                return;
            }

            // Default: It's a new consonant sequence
            clearSequence(true);
            keySequence = key;
            const baseFidel = physicalKeyMapping[keySequence];
            if (baseFidel && fidelGroups[baseFidel]) {
                displayVariations(baseFidel);
                sequenceTimer = setTimeout(() => clearSequence(true), SEQUENCE_TIMEOUT);
            } else {
                keySequence = ''; // Invalid sequence
            }
        }

        // --- Initialization ---
        function init() {
            // Use a DocumentFragment for performance
            const fragment = document.createDocumentFragment();

            keyboardLayout.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                row.forEach(keyChar => {
                    const keyElement = document.createElement('button');
                    keyElement.textContent = keyChar;
                    keyElement.classList.add('key');
                    keyElement.dataset.key = keyChar; // Use data attributes for clarity
                    rowDiv.appendChild(keyElement);
                });
                // Prepend the variation keys container to the main keyboard container,
                // then append the generated rows.
                // This ensures variationKeys is always at the top *inside* keyboard-container
                if (!keyboardContainer.contains(variationKeysContainer)) { // Add it only once
                     fragment.insertBefore(variationKeysContainer, fragment.firstChild);
                }
                fragment.appendChild(rowDiv);
            });
             keyboardContainer.appendChild(fragment);


            // Add single, delegated event listener
            keyboardContainer.addEventListener('click', handleVirtualKeyboardClick);
            outputTextarea.addEventListener('keydown', handlePhysicalKeyboardDown);

            // Clear variations when clicking away
            document.addEventListener('click', (event) => {
                if (!keyboardContainer.contains(event.target) && event.target !== outputTextarea) {
                    variationKeysContainer.innerHTML = '';
                    clearSequence();
                }
            });
        }

        init();
    });
    </script>

    <footer> Developed by: Ahmedhaji Sadik | +251945033132  </footer>

</body>
</html>
